# Codingame SpringChallenge 2021

## 問題概要

https://inaniwa.hatenablog.com/entry/2021/05/07/031102

## アルゴリズム

- 一人ゲームと考えた Chokudai Search
  - 相手は常に wait
  - (day, turn) をキーとするたくさんのキューを用意
    - 最終的には 6 日各 8 ターンの 48 個
- Zobrist Hashing による盤面重複列挙
  - ちゃんとした hash table を用意するのが面倒だったので、hash 値が重複したら大きい方だけ残す雑 hash
    - unordered_map は遅いだろうとは思っていた
      - 実際に遅くて hash table 作った参加者はいたっぽい
- 人力評価関数
  - 太陽ポイント / 3
    - /3 が最終得点にもなるし何かと都合が良かった
  - 影にペナルティをつける
    - 最終日近くになるとペナルティがほぼ 0 になるように 日数をパラメータに入れる
  - 相手がこのターンまでにこれぐらい得点を取ってくるだろうという埋め込みの配列を作り、自身の得点をどのターンにとったかによって動的に変化
  - 自身の木のサイズの総和によるボーナス
    - 最終日近くになるとボーナスがほぼ 0 になるように 日数をパラメータに入れる

## うまくいったこと

### AWS の EC2 インスタンスを使って 性能測定

手元の Docker 環境だと `perf` コマンドが使えなかったので、 Ubuntu インスタンスを作成してそこで測定（本来の目的は Optuna 試行高速化）。
flamegraph を使ったボトルネック可視化がとても便利で、いつも手探りで行っていたボトルネック検出&高速化作業がとても快適になった。

なんか bitset がめちゃんこ遅かった

### タイムアウト時間の正確な測定

プレイヤーが二人以上いるタイプの時間測定が初めてまともにできた気がする
入力のうち最初の行をとってから測定開始とするとかなり精度が高くなる

## うまくいかなかったこと

### Chokudai Search で使う 盤面の状態をバイナリ列に圧縮するのをしていたが、圧縮が遅くあまり意味なかった

そのまま vector に突っ込んで、State のある id をキューに突っ込むほうが断然よかった。
毎ターンの初期化が重くなる時があったので、State 自体の容量を小さくする工夫をしたほうがよさそう。

### Optuna によるパラメータチューニング

評価関数のパラメータチューニングを Optuna で実施しようとしたが、以下の理由で失敗。。。

- 1 回の試行が長く、回数を稼げなかった
  - 勝率について有意差を出すためには、ただでさえ長い一回の対戦を何十試合もやる必要があり無限。。。
  - かなりの並列化が必要かも
- 初めて使用するのもあり、外れ値への対処ができなかった
  - 絶対外れ値を検出してよしなにパラメータ抽出する機能があるはずなので、次はそれを使いたい

## やるべきだったこと

### Chokudai Search の質の評価

- ターン数
- ハッシュのとり方
- ターン毎の評価関数の数値感

コンテスト後に上記の項目のチェックを実施した結果、ターン数を長く取りすぎていて、序盤の評価関数のスコアがいい選択しか使われていないことがわかった
これを修正してターン数を大幅に絞り、ループ数を増やして盤面の多様性をカバーしたところ勝率がかなり安定するようになった（50 位前後）
何らかの手段で可視化する方法を確立したほうがよさそう
